<script>
  // Respect reduced motion
  const vid = document.getElementById('bgvid');
  if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) { vid && vid.pause(); }

  // Auto-advance from HERO to Showcase on first downward action
  (function(){
    const hero = document.getElementById('home');
    const next = document.getElementById('showcase');
    if(!hero || !next) return;
    let fired = false;

    // After auto-scroll, center the first card
    const goNext = ()=>{
      if (fired) return; fired = true;
      next.scrollIntoView({behavior:'smooth'});
      // Allow the section to settle, then center first
      setTimeout(()=>{ window.centerShowcaseFirst?.(); fired = false; }, 700);
    };

    hero.addEventListener('wheel',(e)=>{ if(e.deltaY>12){ e.preventDefault(); goNext(); }},{passive:false});
    hero.addEventListener('keydown',(e)=>{ if(['ArrowDown','PageDown',' '].includes(e.key)){ e.preventDefault(); goNext(); }});
    let sy=null;
    hero.addEventListener('touchstart',(e)=>{ sy=e.touches[0].clientY; },{passive:true});
    hero.addEventListener('touchmove',(e)=>{ if(sy===null) return; const dy=sy-e.touches[0].clientY; if(dy< -18){ e.preventDefault(); goNext(); sy=null; }},{passive:false});
    hero.addEventListener('touchend',()=>{ sy=null; });
    hero.tabIndex=-1; hero.focus({preventScroll:true});
  })();

  // ===== Horizontal rail behavior + CENTER ZOOM selection + FORCE FIRST CENTER =====
  (function(){
    const rail = document.getElementById('rail');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const showcase = document.getElementById('showcase');
    if(!rail || !showcase) return;

    const cards = Array.from(rail.querySelectorAll('.hcard'));

    // Utility: apply "is-center" to the card whose center is closest to rail center
    function currentCenterIndex(){
      const railRect = rail.getBoundingClientRect();
      const railCenter = railRect.left + railRect.width/2;
      let bestIdx=0, bestDist=Infinity;
      cards.forEach((c,i)=>{
        const r=c.getBoundingClientRect();
        const d=Math.abs((r.left + r.width/2) - railCenter);
        if(d<bestDist){ bestDist=d; bestIdx=i; }
      });
      return bestIdx;
    }
    function selectCenter(){
      const idx = currentCenterIndex();
      cards.forEach((c,i)=> c.classList.toggle('is-center', i===idx));
    }

    // Precisely center card by index (no rounding issues)
    function centerCardByIndex(idx, behavior='smooth'){
      const card = cards[idx];
      if(!card) return;
      // scrollLeft so that card center aligns to rail center
      const target = card.offsetLeft + card.offsetWidth/2 - rail.clientWidth/2;
      rail.scrollTo({ left: target, behavior });
      // set class after a tick
      setTimeout(selectCenter, behavior === 'smooth' ? 250 : 0);
    }

    // Expose for the hero auto-scroll to call
    window.centerShowcaseFirst = ()=> centerCardByIndex(0, 'smooth');

    // On page load (after images decode), center first card
    const imgs = Array.from(rail.querySelectorAll('img'));
    Promise.allSettled(imgs.map(img => img.decode?.() ?? Promise.resolve()))
      .finally(()=>{ centerCardByIndex(0, 'instant'); });

    // When showcase becomes visible (e.g., user scrolls manually), center first once
    let centeredOnEnter = false;
    new IntersectionObserver((entries)=>{
      entries.forEach(e=>{
        if(e.isIntersecting && !centeredOnEnter){
          centeredOnEnter = true;
          centerCardByIndex(0, 'smooth');
        }
      });
    }, { root: null, threshold: 0.6 }).observe(showcase);

    // Convert vertical wheel to horizontal scroll on the rail
    rail.addEventListener('wheel', (e)=>{
      if(Math.abs(e.deltaY) > Math.abs(e.deltaX)){
        e.preventDefault();
        rail.scrollLeft += e.deltaY;
      }
    }, {passive:false});

    // Drag-to-scroll with momentum
    let down=false, sx=0, sl=0, vel=0, raf=null, lx=0, lt=0;
    const stop=()=>{ if(raf){ cancelAnimationFrame(raf); raf=null; } };
    const momentum=()=>{ rail.scrollLeft -= vel; vel*=0.95; if(Math.abs(vel)>0.3){ raf=requestAnimationFrame(momentum); } else { selectCenter(); } };

    rail.addEventListener('mousedown', (e)=>{ down=true; sx=e.pageX; sl=rail.scrollLeft; stop(); lx=sx; lt=performance.now(); rail.style.cursor='grabbing'; });
    window.addEventListener('mousemove', (e)=>{ if(!down) return; const now=performance.now(); const dx=e.pageX-sx; rail.scrollLeft=sl-dx; vel=(e.pageX-lx)/(now-lt)*16; lx=e.pageX; lt=now; selectCenter(); });
    window.addEventListener('mouseup', ()=>{ if(!down) return; down=false; rail.style.cursor='grab'; stop(); momentum(); });

    // Touch
    rail.addEventListener('touchstart', (e)=>{ down=true; sx=e.touches[0].pageX; sl=rail.scrollLeft; stop(); lx=sx; lt=performance.now(); }, {passive:true});
    rail.addEventListener('touchmove', (e)=>{ if(!down) return; const now=performance.now(); const dx=e.touches[0].pageX-sx; rail.scrollLeft=sl-dx; vel=(e.touches[0].pageX-lx)/(now-lt)*16; lx=e.touches[0].pageX; lt=now; selectCenter(); }, {passive:true});
    rail.addEventListener('touchend', ()=>{ if(!down) return; down=false; stop(); momentum(); });

    // Arrow buttons move by one card (from current center)
    function moveByCard(dir){
      const idx = currentCenterIndex();
      const targetIdx = Math.max(0, Math.min(cards.length-1, idx + dir));
      centerCardByIndex(targetIdx, 'smooth');
    }
    leftBtn.addEventListener('click', ()=>moveByCard(-1));
    rightBtn.addEventListener('click', ()=>moveByCard(+1));

    // Update on scroll (throttled via rAF)
    let ticking=false;
    rail.addEventListener('scroll', ()=>{
      if(!ticking){ requestAnimationFrame(()=>{ selectCenter(); ticking=false; }); ticking=true; }
    });

    // Recalculate on resize
    window.addEventListener('resize', ()=>{ setTimeout(()=>centerCardByIndex(currentCenterIndex(), 'instant'), 80); });

    // Initial selection (in case images already cached)
    selectCenter();
  })();

  // Year
  document.getElementById('year').textContent = new Date().getFullYear();
</script>
